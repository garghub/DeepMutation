package edu.wm.cs.mutation.abstractor;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import edu.wm.cs.mutation.Consts;
import edu.wm.cs.mutation.abstractor.lexer.MethodLexer;
import edu.wm.cs.mutation.abstractor.parser.MethodParser;
import edu.wm.cs.mutation.io.IOHandler;

public class MethodAbstractor {
    private static LinkedHashMap<String, String> absMethodsMap = new LinkedHashMap<>();
    private static LinkedHashMap<String, String> dictMap = new LinkedHashMap<>();
    private static int tokenThr = 50; // default maximum number of tokens in a method
    private static boolean specified = false;

    // Set of common source code strings that are not abstracted
    private static Set<String> idioms;

    /**
     * Abstract methods generated by {@link edu.wm.cs.mutation.extractor.MethodExtractor}.
     *
     * @param rawMethods Map of method signatures to bodies
     * @param idiomPath  Path to idioms.csv
     */
    public static void abstractMethods(LinkedHashMap<String, String> rawMethods, String idiomPath) {

        System.out.println("Abstracting methods... ");

        absMethodsMap.clear();

        if (rawMethods == null || rawMethods.size() == 0) {
            System.err.println("  ERROR: null/empty input map");
            return;
        }

        // Read idioms
        idioms = readIdioms(idiomPath);
        if (idioms == null) {
            System.err.println("  Could not load idioms");
            return;
        }

        int unparseable = 0;
        int tooLong = 0;
        dictMap.clear();

        // Abstract method bodies
        for (String signature : rawMethods.keySet()) {
            String srcCode = rawMethods.get(signature);

            String absCode = abstractCode(signature, srcCode);

            if (absCode == null) {
                unparseable++;
                continue;
            }

            // If no user-specified methods, enforce token limit
            if (!specified && absCode.split(" ").length > tokenThr) {
                tooLong++;
                continue;
            }

            absMethodsMap.put(signature, absCode); // replace srcCode with absCode
        }
        System.out.println("  There were " + unparseable + " unparseable methods.");
        System.out.println("  There were " + tooLong + " methods longer than " + tokenThr + " tokens.");
        System.out.println("  There are " + absMethodsMap.size() + " remaining methods.");

        System.out.println("done.");
    }

    /**
     * Abstract a single method and store mappings for future translation.
     *
     * @param signature Method signature
     * @param srcCode   Method body
     * @return
     */
    private static String abstractCode(String signature, String srcCode) {
        // Parse
        MethodParser parser = new MethodParser();

        try {
            parser.parse(srcCode);
        } catch (Exception e) {
            System.err.println("  Exception while parsing " + signature + "; ignored method.");
            return null;
        } catch (StackOverflowError e) {
            System.err.println("  StackOverflowError while parsing " + signature + "; ignored method.");
            return null;
        }

        // Tokenize
        MethodLexer tokenizer = new MethodLexer();

        tokenizer.setTypes(parser.getTypes());
        tokenizer.setMethods(parser.getMethods());
        tokenizer.setIdioms(idioms);

        String afterTokenized = tokenizer.tokenize(srcCode);
        String mappings = tokenizer.getMapping();
        if (specified || afterTokenized.split(" ").length <= tokenThr)
            dictMap.put(signature, mappings);

        return afterTokenized;
    }

    /**
     * Write abstracted method signatures to outPath/methods.key and
     * respective bodies to outPath/methods.abs.
     *
     * @param outPath Path to output directory
     */
    public static void writeMethods(String outPath) {
        System.out.println("Writing abstracted methods... ");

        if (absMethodsMap == null) {
            System.err.println("  ERROR: cannot write null map");
            return;
        }

        List<String> signatures = new ArrayList<>(absMethodsMap.keySet());
        List<String> bodies = new ArrayList<>(absMethodsMap.values());

        try {
            Files.createDirectories(Paths.get(outPath));
            Files.write(Paths.get(outPath + File.separator + Consts.METHODS + Consts.KEY_SUFFIX), signatures);
            Files.write(Paths.get(outPath + File.separator + Consts.METHODS + Consts.ABS_SUFFIX), bodies);
        } catch (IOException e) {
            e.printStackTrace();
        }
        System.out.println("done.");
    }

    /**
     * Write method mappings to outPath/methods.map.
     * Format: variables;types;methods;strings;chars;ints;floats
     *
     * @param outPath Path to output directory
     */
    public static void writeMappings(String outPath) {
        System.out.println("Writing mappings... ");

        if (dictMap == null) {
            System.err.println("ERROR: cannot write null input mappings");
            return;
        }
        List<String> mappings = new ArrayList<>(dictMap.values());
        try {
            Files.write(Paths.get(outPath + File.separator + Consts.METHODS + Consts.MAP_SUFFIX), mappings);
        } catch (IOException e) {
            e.printStackTrace();
        }
        System.out.println("done.");
    }

    /**
     * Populate {@link MethodAbstractor#absMethodsMap} from outPath/methods.{key,abs}.
     *
     * @param outPath Path to directory containing methods.{key,abs}
     */
    public static void readMethods(String outPath) {
        System.out.println("Reading abstracted methods from file... ");

        absMethodsMap.clear();

        List<String> signatures = null;
        List<String> bodies = null;
        try {
            signatures = Files.readAllLines(Paths.get(outPath + File.separator + Consts.METHODS + Consts.KEY_SUFFIX));
            bodies = Files.readAllLines(Paths.get(outPath + File.separator + Consts.METHODS + Consts.ABS_SUFFIX));
        } catch (IOException e) {
            e.printStackTrace();
        }

        if (signatures == null || bodies == null) {
            System.err.println("  ERROR: could not load map from files");
            return;
        }

        if (signatures.size() != bodies.size()) {
            System.err.println("  ERROR: unequal number of keys and values");
            return;
        }

        for (int i = 0; i < signatures.size(); i++) {
            absMethodsMap.put(signatures.get(i), bodies.get(i));
        }

        System.out.println("  Read " + absMethodsMap.size() + " methods.");
        System.out.println("done.");
        return;
    }

    /**
     * Populate {@link MethodAbstractor#dictMap} from outPath/methods.{key,map}.
     *
     * @param outPath Path to directory containing methods.{key,map}
     */
    public static void readMappings(String outPath) {
        System.out.println("Reading mappings from file... ");
        dictMap = new LinkedHashMap<>();

        List<String> signatures = null;
        List<String> mappings = null;
        try {
            signatures = Files.readAllLines(Paths.get(outPath + File.separator + Consts.METHODS + Consts.KEY_SUFFIX));
            mappings = Files.readAllLines(Paths.get(outPath + File.separator + Consts.METHODS + Consts.MAP_SUFFIX));

        } catch (IOException e) {
            e.printStackTrace();
        }

        if (signatures == null || mappings == null) {
            System.err.println("  ERROR: could not load map from files");
            return;
        }

        if (signatures.size() != mappings.size()) {
            System.err.println("  ERROR: unequal number of keys and values");
            return;
        }

        for (int i = 0; i < signatures.size(); i++) {
            dictMap.put(signatures.get(i), mappings.get(i));
        }

        System.out.println("  Read " + dictMap.size() + " mappings.");
        System.out.println("done.");
        return;
    }

    /**
     * Read idioms
     *
     * @param filePath Path to idioms file
     * @return
     */
    private static Set<String> readIdioms(String filePath) {
        try (Stream<String> stream = Files.lines(Paths.get(filePath))) {
            return stream.collect(Collectors.toSet());
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }


    public static LinkedHashMap<String, String> getAbstractedMethods() {
        return absMethodsMap;
    }

    public static LinkedHashMap<String, String> getMappings() {
        return dictMap;
    }

    public static void setAbstractedMethods(LinkedHashMap<String, String> absMethodsMap) {
        MethodAbstractor.absMethodsMap = absMethodsMap;
    }

    public static void setMappings(LinkedHashMap<String, String> dictMap) {
        MethodAbstractor.dictMap = dictMap;
    }

    public static void setInputMode(boolean specified) {
        MethodAbstractor.specified = specified;
    }

    public static void setTokenThreshold(int tokenThr) {
        MethodAbstractor.tokenThr = tokenThr;
    }
}
