package edu.wm.cs.mutation.extractor;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;

import edu.wm.cs.mutation.Consts;
import spoon.SpoonAPI;
import spoon.reflect.cu.SourcePosition;
import spoon.reflect.declaration.CtMethod;
import spoon.reflect.declaration.CtType;
import spoon.reflect.declaration.CtTypeInformation;
import spoon.reflect.visitor.filter.TypeFilter;

public class MethodExtractor {

    public static final String D4J_REV_TYPE = File.separator + "b" + File.separator;

    // method signature -> method source code
    private static LinkedHashMap<String, String> rawMethodsMap = new LinkedHashMap();

    // list of ALL methods generated by Spoon
    private static List<CtMethod> methods;

    /**
     * Extracts methods from a project using Spoon.
     * Results are stored in {@link MethodExtractor#rawMethodsMap}.
     *
     * @param projPath         Path to project directory
     * @param srcPath          Path to source root directory
     * @param libPath          Path to library directory
     * @param complianceLvl    Project SDK level
     * @param compiled
     * @param inputMethodsPath Path to file with user-specified method signatures
     */
    public static void extractMethods(String projPath, String srcPath, String libPath,
                                      int complianceLvl, boolean compiled, String inputMethodsPath) {
        System.out.println("Extracting methods from " + projPath + "... ");

        rawMethodsMap.clear();

        // Read user-specified methods
        Set<String> inputMethods = null;
        if (inputMethodsPath != null) {
            inputMethods = readInputMethods(inputMethodsPath);
        }

        // Build spoon model
        buildModel(projPath, srcPath, libPath, complianceLvl, compiled);

        // Select methods
        int userMethods = 0;
        int interfaceMethods = 0;
        for (CtMethod method : methods) {
            String signature = method.getParent(CtType.class).getQualifiedName() + "#" + method.getSignature();

            // If provided input methods, ignore the others
            if (inputMethods != null) {
                if (inputMethods.contains(signature)) {
                    userMethods++;
                } else {
                    continue;
                }
            }

            // If not provided input methods, filter out getters/setters
            if (inputMethods == null) {
                String methodName = method.getSignature().split(" ")[1];
                if (methodName.startsWith("set") || methodName.startsWith("get")) {
                    continue;
                }
            }

            // Filter out interface methods
            if (((CtTypeInformation) method.getParent()).isInterface()) {
                interfaceMethods++;
                continue;
            }

            // Extract the source code body of the method
            SourcePosition sp = method.getPosition();
            String body = sp.getCompilationUnit()
                    .getOriginalSourceCode()
                    .substring(sp.getSourceStart(), sp.getSourceEnd() + 1);

            rawMethodsMap.put(signature, body);
        }

        if (rawMethodsMap.size() == 0) {
            System.err.println("  ERROR: Could not extract any methods.");
        } else {
            if (inputMethods != null) {
                System.out.println("  Found " + userMethods + File.separator + inputMethods.size() + " user-specified methods.");
                System.out.println("  Ignored " + interfaceMethods + " interface methods.");
            }
            System.out.println("  Extracted " + rawMethodsMap.size() + " methods.");
        }
        System.out.println("done.");
    }

    /**
     * Extract methods given a {@link Defects4JInput}.
     *
     * @param input            Defects4J input
     * @param libPath          Path to library directory
     * @param compiled
     * @param inputMethodsPath Path to file with user-specified method signatures
     */
    public static void extractMethods(Defects4JInput input, String libPath, boolean compiled, String inputMethodsPath) {
        extractMethods(input.getProjPath(), input.getSrcPath(), libPath, input.getComplianceLvl(), compiled, inputMethodsPath);
    }

    /**
     * Generate list of {@link Defects4JInput}s.
     *
     * @param projBasePath    Path to directory holding revision directories
     * @param outBasePath     Path to output directory
     * @param modelConfigPath Path to model config JSON file
     * @return
     */
    public static List<Defects4JInput> generateDefect4JInputs(String projBasePath, String outBasePath, String modelConfigPath) {

        ModelConfig modelConfig = new ModelConfig();
        modelConfig.init(modelConfigPath);
        File[] revisions = new File(projBasePath).listFiles(File::isDirectory);
        sortRevisionDirectories(revisions);

        List<Defects4JInput> inputs = new ArrayList<>();
        for (File rev : revisions) {
            int confID = Integer.parseInt(rev.getName());

            String projPath = projBasePath + rev.getName() + MethodExtractor.D4J_REV_TYPE;
            String srcPath = projPath + modelConfig.getSrcPath(confID);
            String outPath = outBasePath + rev.getName() + MethodExtractor.D4J_REV_TYPE;
            int complianceLvl = modelConfig.getComplianceLevel(confID);

            inputs.add(new Defects4JInput(projPath, srcPath, outPath, complianceLvl));
        }

        return inputs;
    }

    /**
     * Generate list of all methods using Spoon API.
     * Results are stored in {@link MethodExtractor#methods}.
     *
     * @param projPath      Path to project directory
     * @param srcPath       Path to source root directory
     * @param libPath       Path to library directory
     * @param complianceLvl Project SDK level
     * @param compiled
     */
    public static void buildModel(String projPath, String srcPath, String libPath,
                                  int complianceLvl, boolean compiled) {
        System.out.println("  Building AST... ");

        File project = new File(projPath);
        if (compiled) {
            libPath = project.getAbsolutePath() + File.separator;
        }

        // May take a while...
        SpoonAPI spoon = SpoonConfig.buildModel(srcPath, complianceLvl, libPath, compiled);

        methods = spoon.getFactory()
                .Package()
                .getRootPackage()
                .getElements(new TypeFilter<>(CtMethod.class));

        System.out.println("  done.");
    }

    /**
     * Sort revision directories by revision number.
     *
     * @param revisions
     */
    private static void sortRevisionDirectories(File[] revisions) {
        Arrays.sort(revisions, new Comparator<File>() {
            public int compare(File f1, File f2) {
                try {
                    int i1 = Integer.parseInt(f1.getName());
                    int i2 = Integer.parseInt(f2.getName());
                    return i1 - i2;
                } catch (NumberFormatException e) {
                    throw new AssertionError(e);
                }
            }
        });
    }

    /**
     * Write extracted method signatures to outPath/methods.key and
     * respective bodies to outPath/methods.src.
     *
     * @param outPath Path to output directory
     */
    public static void writeMethods(String outPath) {
        System.out.println("Writing extracted methods... ");

        if (rawMethodsMap == null) {
            System.err.println("  ERROR: cannot write null map");
            return;
        }

        List<String> signatures = new ArrayList<>(rawMethodsMap.keySet());
        List<String> bodies = new ArrayList<>(rawMethodsMap.values());

        try {
            Files.createDirectories(Paths.get(outPath));
            Files.write(Paths.get(outPath + File.separator + Consts.METHODS + Consts.KEY_SUFFIX), signatures);
            Files.write(Paths.get(outPath + File.separator + Consts.METHODS + Consts.SRC_SUFFIX), bodies);
        } catch (IOException e) {
            e.printStackTrace();
        }
        System.out.println("done.");
    }

    /**
     * Read user-specified method signatures from file.
     *
     * @param methodPath Path to input methods file.
     * @return
     */
    private static HashSet<String> readInputMethods(String methodPath) {
        System.out.println("  Reading specified methods from input file... ");

        List<String> methods = null;
        try {
            methods = Files.readAllLines(Paths.get(methodPath));
        } catch (IOException e) {
            System.err.println("    ERROR: could not load specified methods from files: " + e.getMessage());
        }

        if (methods == null) {
            System.err.println("    ERROR: could not load specified methods from files");
            return null;
        }

        System.out.println("  done.");
        return new HashSet<>(methods);
    }

    public static LinkedHashMap<String, String> getRawMethodsMap() {
        return rawMethodsMap;
    }

    public static List<CtMethod> getMethods() {
        return methods;
    }

    public static void setMethods(List<CtMethod> methods) {
        MethodExtractor.methods = methods;
    }

    public static void setRawMethodsMap(LinkedHashMap<String, String> rawMethodsMap) {
        MethodExtractor.rawMethodsMap = rawMethodsMap;
    }

}
